* GENERATED BY CHARMM-GUI (http://www.charmm-gui.org)
* POLYMER PACKING
*

! read topology and parameter files
DIMENS CHSIZE 5000000 MAXRES 3000000

! Read topology and parameter files
stream toppar.str

stream polymer.step0.str
set crystalf = toppar/step1_crystal_image2.str


! User's input is the number of chain (ncha) and the monomer (nmon)
!
!
! === Initial setting ===
! - reading each fragment structure's radius
! - selecting an appropriate sphere for packing
!

open read unit 20 card name step2.1_gen_kuhn_lattice_model.psf
read psf  unit 20 card

stream openmm.bead/step4_equilibration.str
open read unit 11 file name openmm.bead/step4_equilibration.dcd
traj query unit 11
traj iread 11 nread 1 skip 1
calc nfile = ?NFILE

! read only last snapshot from dcd
calc cnt = 1
label readtrj
     traj read
     incr cnt by 1
     if cnt .lt. @nfile goto readtrj


autogen off
bomlev -1


calc this_struct = 1
label do_rep_struct
   set icha = 1
   label do_rep_ch
   calc isphe = 1
      label do_rep_sp
         define POLB sele all end
         set btype = @{P@@{this_struct}F@@{isphe}}
         coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype}@{isphe} end
         calc x0 = ?xave
         calc y0 = ?yave
         calc z0 = ?zave
         calc nsphe = @{nsphe_@@{this_struct}}

         if nsphe .eq. 1 then 
            coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype}@{isphe} end
            calc x1 = ?xave
            calc y1 = ?yave
            calc z1 = ?zave 
            calc x1m = ( @x1 + 1.0 )
            calc y1m = ( @y1 + 1.0 )
            calc z1m = ( @z1 + 1.0 )
            calc x2m = ( @x1 - 1.0 )
            calc y2m = ( @y1 - 1.0 )
            calc z2m = ( @z1 - 1.0 )

            calc sang = 180
            open read unit 10 card name psfcrdreader/P@{this_struct}F@{nsphe}_@sang.psf
            read psf  unit 10 card append
            open read unit 10 card name psfcrdreader/P@{this_struct}F@{nsphe}_@sang.crd
            read coor unit 10 card append
            coor stat  sele .not. POLB end
            set iseg = ?SELSEGI
            rename segid S@{this_struct}P@icha sele segid @iseg end

         else
            if isphe .eq. 1 then 
               coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype}@{isphe} end
               calc x1 = ?xave
               calc y1 = ?yave
               calc z1 = ?zave 
           
               calc jsphe = @isphe + 1
               set btype2 = @{P@@{this_struct}F@@{jsphe}}
               coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype2}@{jsphe} end
               set x2 = ?xave
               set y2 = ?yave
               set z2 = ?zave
               calc x1m = @x1 - @x2 
               calc y1m = @y1 - @y2
               calc z1m = @z1 - @z2
               calc x2m = @x2 - @x1 
               calc y2m = @y2 - @y1 
               calc z2m = @z2 - @z1 

               calc sang = 180
               open read unit 10 card name psfcrdreader/P@{this_struct}F@{isphe}_@sang.psf
               read psf  unit 10 card append
               open read unit 10 card name psfcrdreader/P@{this_struct}F@{isphe}_@sang.crd
               read coor unit 10 card append
               coor stat  sele .not. POLB end 
               set iseg = ?SELSEGI
               rename segid S@{this_struct}P@icha sele segid @iseg end
            else
               if isphe .ne. @{nsphe_@@{this_struct}} then    
                  calc hsphe = @isphe - 1
                  calc jsphe = @isphe + 1
                  set btype1 = @{P@@{this_struct}F@@{hsphe}}
                  set btype2 = @{P@@{this_struct}F@@{jsphe}}
                  coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype1}@{hsphe} end
                  calc x1 = ?xave
                  calc y1 = ?yave
                  calc z1 = ?zave 
                  coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype}@{isphe} end
                  calc x2 = ?xave
                  calc y2 = ?yave
                  calc z2 = ?zave 
                  coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype2}@{jsphe} end
                  calc x3 = ?xave
                  calc y3 = ?yave
                  calc z3 = ?zave 
           
                  calc x1temp = ( @x1 + @x2 ) / 2
                  calc y1temp = ( @y1 + @y2 ) / 2
                  calc z1temp = ( @z1 + @z2 ) / 2
               
                  calc x2temp = ( @x3 + @x2 ) / 2
                  calc y2temp = ( @y3 + @y2 ) / 2
                  calc z2temp = ( @z3 + @z2 ) / 2
                   
                  calc x1m = @x1temp - @x2
                  calc y1m = @y1temp - @y2
                  calc z1m = @z1temp - @z2
                  calc x2m = @x2temp - @x2
                  calc y2m = @y2temp - @y2
                  calc z2m = @z2temp - @z2
                  
                  calc xi = @x2temp - @x1temp
                  calc yi = @y2temp - @y1temp
                  calc zi = @z2temp - @z1temp
                  calc sighalf = @rad / 2
                  calc vleng = sqrt ( @xi * @xi + @yi * @yi + @zi * @zi )
                  calc limit = @sighalf * 2
                  if vleng .gt. @limit then 
                     calc sang = 180
                  else
                     calc sang_raw = acos(@vleng / ( @sighalf * 2 )) * 180 / ?PI 
                     calc sang = 180 - int ( 2 * @{sang_raw} / 10 ) * 10
                  endif
                  if sang .lt. 50 calc sang = 50
                  !set tname = @{fname@@{this_struct}@@{isphe}}
                  !calc i = 2
                  !calc endi = @nsphe - 1
                  !label findname
                  !   if tname .eq. f@{this_struct}@i set file = f@{this_struct}@{i}
                  !incr i
                  !if i .le. @endi goto findname
                  set file = P@{this_struct}F@{isphe}
                  open read unit 10 card name psfcrdreader/@file_@sang.psf
                  read psf  unit 10 card append
                  open read unit 10 card name psfcrdreader/@file_@sang.crd
                  read coor unit 10 card append
                  coor stat  sele .not. POLB end 
                  join S@{this_struct}P@icha ?SELSEGI renumber
              endif    
              if isphe .eq. @nsphe then
                  coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype}@{isphe} end
                  calc x1 = ?xave
                  calc y1 = ?yave
                  calc z1 = ?zave 
                  
           
                  calc jsphe = @isphe - 1
                  set btype2 = @{P@@{this_struct}F@@{jsphe}}
                  coor stat sele segid P@{this_struct} .and. resid @icha .and. type @{btype2}@{jsphe} end
                  set x2 = ?xave
                  set y2 = ?yave
                  set z2 = ?zave 
                  calc x1m = @x2 - @x1 
                  calc y1m = @y2 - @y1
                  calc z1m = @z2 - @z1
                  calc x2m = @x1 - @x2
                  calc y2m = @y1 - @y2
                  calc z2m = @z1 - @z2 
                  calc sang = 180
                  set file = P@{this_struct}F@{isphe}
                  open read unit 10 card name psfcrdreader/@file_@sang.psf
                  read psf  unit 10 card append
                  open read unit 10 card name psfcrdreader/@file_@sang.crd
                  read coor unit 10 card append
                  coor stat  sele .not. POLB  end 
                  join S@{this_struct}P@icha ?SELSEGI renumber

              endif
            endif  
         endif
         prnlev 0

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !! find start and end atoms !!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         if isphe .eq. 1 then
            calc sresid = 1
            calc eresid = @{nm@@{this_struct}r1}
         else
            calc cnt = 1
            calc cntsum = 0
            calc cntmax = @isphe - 1
            label cntresid
               calc cntsum = @{cntsum} + @{nm@@{this_struct}r@@{cnt}}
               incr cnt by 1
            if cnt .le. @cntmax goto cntresid
            calc sresid = @{cntsum} + 1
            calc eresid = @{cntsum} + @{nm@@{this_struct}r@@{isphe}}
         endif

         coor stat sele segid S@{this_struct}P@{icha} .and. resid @sresid end
         set sname = ?selresn
         coor stat sele segid S@{this_struct}P@{icha} .and. resid @eresid end
         set ename = ?selresn


         calc k = 1
         label seidx
            if sname .eq. @{rn@@{this_struct}r@@{k}} then set sidx = @k
            if ename .eq. @{rn@@{this_struct}r@@{k}} then set eidx = @k
            incr k by 1
         if k .le. @{totmon_@@{this_struct}} goto seidx

         read sequence @sname 2
         generate temp first none last none setup
         patch @{p@@{this_struct}t@@{sidx}n@@{sidx}} temp 1 temp 2 setup warn

         coor stat sele segid temp .and. resid 2  .and. .bonded.  resid 1  show end
         set satom = ?SELTYPE
         set sres = ?selresn
         delete atoms sele segid temp end

         read sequence @ename 2
         generate temp first none last none setup
         patch @{p@@{this_struct}t@@{eidx}n@@{eidx}} temp 1 temp 2 setup warn

         coor stat sele segid temp .and. resid 1  .and. .bonded.  resid 2  show end
         set eatom = ?SELTYPE
         set eres = ?selresn
         delete atoms sele segid temp end

         !rotation 1
         ! 
         ! vector 1 
         !
         coor stat sele segid S@{this_struct}P@{icha} .and. resid @sresid .and. type @satom end
         calc headx = ?xave
         calc heady = ?yave
         calc headz = ?zave

         calc hnorm = sqrt ( @headx * @headx + @heady * @heady + @headz * @headz )
         calc xvec1 = @headx / @hnorm
         calc yvec1 = @heady / @hnorm
         calc zvec1 = @headz / @hnorm
      
         calc norm = sqrt ( @x1m * @x1m + @y1m * @y1m + @z1m * @z1m )
         calc xvec2 = @x1m / @norm
         calc yvec2 = @y1m / @norm
         calc zvec2 = @z1m / @norm

         ! rotation stream file
         !
         stream toppar/monomer_alignment.str
         
         coor trans xdir @x0 ydir @y0 zdir @z0 sele .not. POLB end 

         calc norm = sqrt ( @x1m * @x1m + @y1m * @y1m + @z1m * @z1m )
         calc base1x = @x1m / @norm
         calc base1y = @y1m / @norm
         calc base1z = @z1m / @norm 
         calc norm = sqrt ( @x2m * @x2m + @y2m * @y2m + @z2m * @z2m )
         calc base2x = @x2m / @norm
         calc base2y = @y2m / @norm
         calc base2z = @z2m / @norm

         calc crsx1 = @base1y * @base2z - @base1z * @base2y
         calc crsy1 = @base1z * @base2x - @base1x * @base2z 
         calc crsz1 = @base1x * @base2y - @base1y * @base2x

         calc norm = sqrt ( @crsx1 * @crsx1 + @crsy1 * @crsy1 + @crsz1 * @crsz1 )
         calc ncrsx1 = @crsx1 / @norm 
         calc ncrsy1 = @crsy1 / @norm 
         calc ncrsz1 = @crsz1 / @norm 

         coor stat sele segid S@{this_struct}P@{icha} .and. resid @sresid .and. type @satom end
         calc headx = ?xave - @x0
         calc heady = ?yave - @y0
         calc headz = ?zave - @z0

         calc hnorm = sqrt ( @headx * @headx + @heady * @heady + @headz * @headz )
         calc xvec1 = @headx / @hnorm
         calc yvec1 = @heady / @hnorm
         calc zvec1 = @headz / @hnorm

         coor stat sele segid S@{this_struct}P@{icha} .and. resid @eresid .and. type @eatom end
         calc tailx = ?xave - @x0
         calc taily = ?yave - @y0
         calc tailz = ?zave - @z0
         calc tnorm = sqrt ( @tailx * @tailx + @taily * @taily + @tailz * @tailz )
         calc xvec2 = @tailx / @tnorm
         calc yvec2 = @taily / @tnorm
         calc zvec2 = @tailz / @tnorm

         calc crsx2 = @yvec1 * @zvec2 - @zvec1 * @yvec2
         calc crsy2 = @zvec1 * @xvec2 - @xvec1 * @zvec2 
         calc crsz2 = @xvec1 * @yvec2 - @yvec1 * @xvec2 
         calc norm = sqrt ( @crsx2 * @crsx2 + @crsy2 * @crsy2 + @crsz2 * @crsz2 )
         calc ncrsx2 = @crsx2 / @norm 
         calc ncrsy2 = @crsy2 / @norm 
         calc ncrsz2 = @crsz2 / @norm 
         calc dotp = @ncrsx1 * @ncrsx2 + @ncrsy1 * @ncrsy2 + @ncrsz1 * @ncrsz2  
         calc phi = acos( @dotp ) * 180 / ?pi

         !determine the rotation direction
         
         calc crsx3 = @base2y * @zvec2 - @base2z * @yvec2
         calc crsy3 = @base2z * @xvec2 - @base2x * @zvec2
         calc crsz3 = @base2x * @yvec2 - @base2y * @xvec2
         calc norm = sqrt ( @crsx3 * @crsx3 + @crsy3 * @crsy3 + @crsz3 * @crsz3 )
         calc ncrsx3 = @crsx3 / @norm
         calc ncrsy3 = @crsy3 / @norm
         calc ncrsz3 = @crsz3 / @norm
         calc dotp = @base1x * @ncrsx3 + @base1y * @ncrsy3 + @base1z * @ncrsz3
         calc tempphi = acos( @dotp ) * 180 / ?pi   
         
         if tempphi .gt. 90 calc phi = -1 * @phi
            
!
!     rotation 2
!   

         if isphe .gt. 1 then 
            calc hsphe = @isphe  - 1         
            set btype = @{P@@{this_struct}F@@{isphe}}
            set btype1 = @{P@@{this_struct}F@@{hsphe}}
            coor axis sele segid P@{this_struct} .and. resid @icha .and. type @{btype}@{isphe} end - 
                      sele segid P@{this_struct} .and. resid @icha .and. type @{btype1}@{hsphe} end
            coor rotate axis sele .not. POLB end phi @phi 
         endif
         
         if isphe .eq. 1 goto rep_skip
         prnlev 5
            
         calc imonum =  @sresid
         calc jmonum = @imonum - 1

         define itemp sele segid S@{this_struct}P@icha .and. resid @imonum end
         set iname = ?selresn
         define jtemp sele segid S@{this_struct}P@icha .and. resid @jmonum end
         set jname = ?selresn
         calc i = 1
         label patidxf
            if iname .eq. @{rn@@{this_struct}r@@{i}} then set iidx = @i
            if jname .eq. @{rn@@{this_struct}r@@{i}} then set jidx = @i
         incr i by 1
         if i .le. @{totmon_@@{this_struct}} goto patidxf
   
         set pname = @{p@@{this_struct}t@@{jidx}n@@{iidx}}
         patch @pname S@{this_struct}P@icha @jmonum S@{this_struct}P@icha @imonum setup warn
      label rep_skip
      incr isphe by 1
      if isphe .le. @{nsphe_@@{this_struct}} goto do_rep_sp

   incr icha by 1
   if icha .le. @{ncha_@@{this_struct}} goto do_rep_ch

incr this_struct 
if this_struct .le. @{num_component} goto do_rep_struct

dele atoms sele segid P* end
dele atoms sele segid SOLV end
autogen angles dihedrals
bomlev 0


prnlev 5
coor stat sele all end

crystal define @BXTYPE @A @B @C 90.0 90.0 90.0
open read unit 10 card name @crystalf
crystal read unit 10 card
close unit 10
calc xhs = @A / 2
calc yhs = @B / 2
calc zhs = @C / 2
IMAGE BYSEGID XCEN @xhs YCEN @yhs ZCEN @zhs

nbonds atom vatom vfswitch bycb -
       ctonnb 10.0 ctofnb 12.0 cutnb 14.0 cutim 14.0 -
       inbfrq -1 imgfrq -1 wmin 1.0 cdie eps 80.0

mini SD    nstep 300 nprint 50
mini ABNR  nstep 300 nprint 50

Energy

system "python checkfft.py ?XTLA ?XTLB ?XTLC > checkfft.str"
stream checkfft.str

stream step2.1_size.str
if @zlayer .gt. 0 calc C = @sizez + @zlayer

open write card unit 10 name step2.3_replacement.pdb
write coor pdb unit 10
open write card unit 10 name step2.3_replacement.crd
write coor  unit 10 card
open write card unit 10 name step2.3_replacement.psf
write psf unit 10 card

open write card unit 90 name step2.3_replacement.str
write title unit 90
* set A = @A
* set B = @B
* set C = @C
* set BXTYPE = @bxtype
* set XTLTYPE = @bxtype
* set alpha = 90.0
* set beta = 90.0
* set gamma = 90.0
* set xcen = @xhs
* set ycen = @yhs
* set zcen = @zhs
* set fftx = @fftx
* set ffty = @ffty
* set fftz = @fftz
* set fftz = @fftz
* set cgtot = ?cgtot
*

stop
