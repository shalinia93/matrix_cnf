"""
Generated by CHARMM-GUI (http://www.charmm-gui.org)

omm_vfswitch.py

This module contains vdW force-switching fuctions for OpenMM.

Correspondance: jul316@lehigh.edu or wonpil@lehigh.edu
Last update: March 29, 2017
"""

import sys, json
from simtk.unit import *
from simtk.openmm import *
from simtk.openmm.app import *

length_conv = angstrom.conversion_factor_to(nanometer)
ene_conv = kilocalorie_per_mole.conversion_factor_to(kilojoule_per_mole)
def vfswitch(system, psf, inputs, wca=False, scale=None, params=None):
    r_on = inputs.r_on
    r_off = inputs.r_off

    # custom nonbonded force for force-switch
    chknbfix = False
    for force in system.getForces():
        if isinstance(force, NonbondedForce):
            nonbonded = force
        if isinstance(force, CustomNonbondedForce):
            nbfix     = force
            chknbfix  = True

    # vfswitch_NBFIX
    if chknbfix:
        if wca:
            system.run_md = True
            nbfix.setEnergyFunction('(1-x) * (step(Ron-r)*(ccnba*tr6*tr6-ccnbb*tr6+ccnbb*onoff3-ccnba*onoff6) \
                                      +step(r-Ron)*step(Roff-r)*(cr12*rjunk6 - cr6*rjunk3) \
                                      -step(r-Ron)*step(Ron-r)*(cr12*rjunk6 - cr6*rjunk3))  \
                                      +x*step(d-r)*((a/r6)^2-b/r6+c); r6=r^6;'
                                      'cr6  = ccnbb*ofdif3*rjunk3; \
                                      cr12 = ccnba*ofdif6*rjunk6; \
                                      rjunk3 = r3-recof3; \
                                      rjunk6 = tr6-recof6; \
                                      r3 = r1*tr2; \
                                      r1 = sqrt(tr2); \
                                      tr6 = tr2 * tr2 * tr2; \
                                      tr2 = 1.0/s2; \
                                      s2 = r*r; \
                                      ccnbb = b; \
                                      ccnba = a*a; \
                                      onoff3 = recof3/on3; \
                                      onoff6 = recof6/on6; \
                                      ofdif3 = off3/(off3 - on3); \
                                      ofdif6 = off6/(off6 - on6); \
                                      recof3 = 1.0/off3; \
                                      on6 = on3*on3; \
                                      on3 = c2onnb*Ron; \
                                      recof6 = 1.0/off6; \
                                      off6 = off3*off3; \
                                      off3 = c2ofnb*Roff; \
                                      c2ofnb = Roff*Roff; \
                                      c2onnb = Ron*Ron; '
                                      'a=acoef(type1, type2);'
                                      'b=bcoef(type1, type2);'
                                      'c=ccoef(type1, type2);'
                                      'd=dcoef(type1, type2);'
                                      'x=xcoef(type1, type2);'
                                      'Ron  = %f; \
                                      Roff = %f;' % (r_on, r_off) )

            lj_types = [atom.attype for atom in psf.atom_list]
            lj_types = list(dict.fromkeys(lj_types))
            num_lj_types = len(lj_types)
            if num_lj_types == 1:
                print("No.monomer unit is 1, you don't need to run WCA...")
                system.run_md = False
            ccoef = [0 for i in range(num_lj_types*num_lj_types)]
            dcoef = ccoef[:]
            xcoef = ccoef[:]

            bead_info = json.load(open('../output.json'))
            if bead_info['has_solvent']:
                ldict = bead_info['lmat']
                if scale:
                    soltb = bead_info['soltb']
                    soltc = bead_info['soltc']
                    scale = soltb / soltc
                else:
                    scale = 1.0
            else:
                cmat = bead_info['cmat']
                scale = 1.0

            for i in range(num_lj_types):
                atype1 = lj_types[i]
                for j in range(num_lj_types):
                    atype2 = lj_types[j]

                    try:
                       wdij = params.nbfix_types[(atype1,atype2)][0] * ene_conv * scale
                       rij = params.nbfix_types[(atype1,atype2)][1] * length_conv
                       print("cross term")
                       print(i, j, atype1, atype2, wdij, rij)
                       ccoef[i+num_lj_types*j] = wdij
                       dcoef[i+num_lj_types*j] = rij
                       #xcoef[i+num_lj_types*j] = 1.0
                       xcoef[i+num_lj_types*j] = 1.0
                       if bead_info['has_solvent']:
                           xcoef[i+num_lj_types*j] = ldict[atype1][atype2]
                       else:
                           if cmat[i][j] == 0:
                               xcoef[i+num_lj_types*j] = 0.0

                    except KeyError:
                        try:
                           wdij = params.nbfix_types[(atype2,atype1)][0] * ene_conv * scale
                           rij = params.nbfix_types[(atype2,atype1)][1] * length_conv
                           print("cross term")
                           print(i, j, atype1, atype2, wdij, rij)
                           ccoef[i+num_lj_types*j] = wdij
                           dcoef[i+num_lj_types*j] = rij
                           xcoef[i+num_lj_types*j] = 1.0
                           if bead_info['has_solvent']:
                               xcoef[i+num_lj_types*j] = ldict[atype1][atype2]
                           else:
                               if cmat[i][j] == 0:
                                   xcoef[i+num_lj_types*j] = 0.0
                        except KeyError:
                            wdij = sqrt(params.atom_types_str[atype1].epsilon * params.atom_types_str[atype2].epsilon) * ene_conv * scale
                            rij = (params.atom_types_str[atype1].rmin + params.atom_types_str[atype2].rmin) / 2.0 * length_conv
                            print("self term")
                            print(i, j, atype1, atype2, wdij, rij)
                            ccoef[i+num_lj_types*j] = 0.0
                            dcoef[i+num_lj_types*j] = (rij * 2)
                            xcoef[i+num_lj_types*j] = 0.0
                            if bead_info['has_solvent']: xcoef[i+num_lj_types*j] = ldict[atype1][atype2]
                    #else:
                    #    wdij *= ene_conv
                    #    rij *= length_conv
            print(ccoef)
            print(dcoef)
            print(xcoef)
            nbfix.addTabulatedFunction('ccoef',
                Discrete2DFunction(num_lj_types, num_lj_types, ccoef))
            nbfix.addTabulatedFunction('dcoef',
                Discrete2DFunction(num_lj_types, num_lj_types, dcoef))
            nbfix.addTabulatedFunction('xcoef',
                Discrete2DFunction(num_lj_types, num_lj_types, xcoef))


        else:
            nbfix.setEnergyFunction('step(Ron-r)*(ccnba*tr6*tr6-ccnbb*tr6+ccnbb*onoff3-ccnba*onoff6) \
                                     +step(r-Ron)*step(Roff-r)*(cr12*rjunk6 - cr6*rjunk3) \
                                     -step(r-Ron)*step(Ron-r)*(cr12*rjunk6 - cr6*rjunk3); \
                                     cr6  = ccnbb*ofdif3*rjunk3; \
                                     cr12 = ccnba*ofdif6*rjunk6; \
                                     rjunk3 = r3-recof3; \
                                     rjunk6 = tr6-recof6; \
                                     r3 = r1*tr2; \
                                     r1 = sqrt(tr2); \
                                     tr6 = tr2 * tr2 * tr2; \
                                     tr2 = 1.0/s2; \
                                     s2 = r*r; \
                                     ccnbb = bcoef(type1, type2); \
                                     ccnba = acoef(type1, type2)^2; \
                                     onoff3 = recof3/on3; \
                                     onoff6 = recof6/on6; \
                                     ofdif3 = off3/(off3 - on3); \
                                     ofdif6 = off6/(off6 - on6); \
                                     recof3 = 1.0/off3; \
                                     on6 = on3*on3; \
                                     on3 = c2onnb*Ron; \
                                     recof6 = 1.0/off6; \
                                     off6 = off3*off3; \
                                     off3 = c2ofnb*Roff; \
                                     c2ofnb = Roff*Roff; \
                                     c2onnb = Ron*Ron; \
                                     Ron  = %f; \
                                     Roff = %f;' % (r_on, r_off) )

        # turn off long range correction (OpenMM Issues: #2353)
        nbfix.setUseLongRangeCorrection(False)
    else:
        if wca:
            print("No.monomer unit is 1, you don't need to run WCA...")
            system.run_md = False
    return system
